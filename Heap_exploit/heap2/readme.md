# FAST BIN DUP 

![image](https://user-images.githubusercontent.com/93699926/227073895-f8946d8b-0a45-4212-8267-7a3563a9eaf7.png)

``` 
 let check out our binary in ida
```
![image](https://user-images.githubusercontent.com/93699926/227073313-82c47267-a26d-4ab8-886b-ba74c4ac72fa.png)
``` 
The program has 5 function and it will run in a infinite loop until we chose option 5 to exit
Let check out each funtion and see what it has and do
```
![image](https://user-images.githubusercontent.com/93699926/227073521-63d04ca5-a7f8-412e-a9c1-dcc440f0d923.png)

``` 
 So the creat func will allow us to request a chunk which smaller than 0x1000 and it prompt us for the index and store the pointer to the heap data in that array  "store"
 and we has 10 index available to request a malloc chunk!
 Next is "Show heap" 
 ```
 ![image](https://user-images.githubusercontent.com/93699926/227074274-2d450051-a2ba-4e17-954e-cd7a6c6e0c0e.png)
``` 
All this function do is that check for if store[index] exist and print out the content in it
Next is "delete"
```
![image](https://user-images.githubusercontent.com/93699926/227074659-82ae94d5-a438-42d0-a02a-5f07c7333b88.png)
```
IN this function we actually got a bug 
when we want the program to delete a chunk it will check (if store[index] ) and free that chunk but it do not set NULL the pointer to that chunk on the heap 
==> use after free bug ( we can use this to leak address)
==> double free bug cause after delete chunk 0 for example we stll got a pointer to that chunk in array store an we can free it again
To summarize : 
We has a use after free bug and we use it to leak the libc address
Use fast bin dup technic to attack the malloc hook and over write it with our one_gadget 
```
``` 
ok the first step is to leak the address
Because we are working again libc-2.23.so version a libc libarary so the tcache is not enable we got fastbin , unsorted bin , large and small bin 
We know that if we free a chunk of fast bin size( every thing under 0x80) the foward pointer of it will point to the heap address and because we are wanting to leak the libc
address so that meaningless
But if we free a chunk of unsorted bin size and the foward and backward pointer of it will pointo the main area of unsorted bin which has the libc address .
That way we can calculate out the libc base address
here is the code for it
``` 
![image](https://user-images.githubusercontent.com/93699926/227077605-8a262fa8-737f-4e1f-a9af-f76a06c9da64.png)
``` 
Step 2 is to over write the __malloc_hook 
let create the double free bug first 
```
![image](https://user-images.githubusercontent.com/93699926/227078347-b9ee63f5-f040-447f-a376-8d9ee9cf5a6f.png)
![image](https://user-images.githubusercontent.com/93699926/227078563-80363340-b054-44cd-b9b0-eb855e74804b.png)
``` checking it in gdb we can see we sucessfully create a double free bug```
``` 
Now is how to overwrite the malloc_hook
becuase the fast bin foward pointer point to the metadata section of the heap so if we want to over write to the __malloc_hook we will need to point it back __malloc_hook -16
but the problem is 16 bytes at  __malloc_hook -16 which is our fake chunk metadata is a very large number and it will not suit with our 0x70 size chunk in the fast bin
so to over come this we will point back __malloc_hook -35
``` 
![image](https://user-images.githubusercontent.com/93699926/227079619-f33b2afc-6781-400a-ac6c-f533f183f1ec.png)
```
Becuase malloc only check if the least significant bit in in the size field is on which reference to that it's pre chunk in use or not so 0x7f chunk still able for us 
to malloc a chunk in fast bin size 0x70
```
![image](https://user-images.githubusercontent.com/93699926/227081275-6baf0e6b-a495-4b32-9df7-a9de36dc79d2.png)

``` the part that (trigger the double investigation of malloc some how call malloc and set the data on stack to NULL ) is a hint from mentor ```
``` 
Run the program and we has pwned a shell
```
![image](https://user-images.githubusercontent.com/93699926/227081491-6245e3ea-be14-4ac1-b636-e9ff5aa59802.png)







 
 
