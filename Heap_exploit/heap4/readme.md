# UNLINK TECHNIC
```
sec check:pie and relro is not enable
```
![image](https://user-images.githubusercontent.com/93699926/227530377-37e18310-1c79-4141-bf6e-91f4cfd6108d.png)
```
this challenge still got 4 main function is create,show,edit and delete
Check out the delete function 
```
![image](https://user-images.githubusercontent.com/93699926/227530866-7f03f03d-e580-470f-9387-f0bcf2e61317.png)
```
we see that after free a chunk it set null the pointer point to that chunk
==> So no uaf or double free
but if we check out the edit function 
we can see that it ask for index and malloc a new size of that store[index] and allow us to write to that new chunk
We can use thhis function as a heap overflow bug
```
![image](https://user-images.githubusercontent.com/93699926/227531509-55883b40-c48c-4c18-9a62-ae1f667c437f.png)
```
Now let go through how we gonna crack this challenge
we going to use a technic called unlink
So unlink is a process of malloc whwn we free a chunk and that chunk get consolidate with top chunk or another chunk
and we know that in unsorted bin ,it use a double link list ,every chunks in unsorted bin has a foward pointer and backward pointer 
for examble if we has chunks in unsorted bin and if we free a chunk and that chunk get consolidate with a chunk in the middle of unsorted bin list it will trigger unlink
This is a well documented explain how this unlink technic work (better than me)
```
![image](https://user-images.githubusercontent.com/93699926/227533940-b547eb35-e624-4bce-bc05-00a5bc16a6a8.png)
```
TO perform this technic we need for 6 chunks
chunk0->chunk2 will be use later as a fake chunk metadata
Chunk5 is just a junk chunk to avoid chunk4 get consolidate with top chunk when we free it
Next we will use chunk 3 to overflow chunk 4 metadata and also create a fakechunk out of chunk3
```
![image](https://user-images.githubusercontent.com/93699926/227535160-6e9b1044-0831-4d58-a07f-7d09b2c169b7.png)
```
check out the heap before we delete chunk4 
```
![image](https://user-images.githubusercontent.com/93699926/227536111-e760345b-6ccd-4692-b68e-a3fd900ac9dd.png)
```
We see that we overweite the metadata of chunk4 to 0xa0 and 0xb0(which indicate that its previous chunks is not in use )
And if we now free chunk4 it will get consolidate with the fake chunk we create out of chunk3
the reason we has store address is because pie is not enable
We set the fd and bk of the fake chunk as store[0] and store[1] is to bypass the investigation of malloc before the unlink process
```
![image](https://user-images.githubusercontent.com/93699926/227537299-0a6b1471-d03b-4967-b3c3-2a52824a3157.png)
```
FD will be our store[0](16byte of metada and the store[2] and store[3] will be the fd and bk of the fake chunk we made out of store[0]
BK will be our store[1](16byte of metada and store[3] and store[4] will be our fd and bk of the fake chunk we made out of store[1]
SO FD->bk is store[3] and BK->fd is store[3] that ay we can bypass the investigation of malloc
and when whe unlink our BK->fd will be over write with address of store 
which mean that we has a pointer point to the the start of store
it maybe confuse the way i explain
Look at this 
```
![image](https://user-images.githubusercontent.com/93699926/227539892-2f7e8849-38ba-4e75-aaea-251058a0a15b.png)

```
We see that store[3] is now point to address of store
That mean we can edit store[3] with the address of some libc function and when we chose function show heap at store[0] it will leak the libc address of
of that libc function and with some calculating we will has the base address
```
![image](https://user-images.githubusercontent.com/93699926/227540672-4bafbfbf-08f4-4f99-a625-b166150549d7.png)
``` 
The last step will be over write atoi@got to system
and when we run the script we pwned a shell
```
![image](https://user-images.githubusercontent.com/93699926/227541141-5088b264-abf7-4351-9df6-20743609bc02.png)


